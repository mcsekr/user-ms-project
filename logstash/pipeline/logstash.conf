input {
  gelf {
    port => 12201
    type => "gelf"
  }

  tcp {
    port => 5000
    codec => json_lines
    type => "json_tcp"
  }
}

filter {
  # Ensure a timestamp is present and has correct type
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss", "UNIX" ]
      target => "@timestamp"
    }
  }

  # If Docker/GELF adds container name or short_name, normalize to service field
  if [container] and [container][name] {
    mutate {
      add_field => { "service" => "%{[container][name]}" }
    }
  } elsif [short_message] and "@" not in [short_message] {
    # fallback: try to use tags or short_message as service hint
    mutate {
      add_field => { "service" => "%{[tags][0]}" }
    }
  }

  # Convert message field to string
  if [message] {
    mutate { convert => { "message" => "string" } }
  }

  # Optional: parse JSON logs emitted by applications
  if [message] =~ /^\s*\{/ {
    json {
      source => "message"
      # keep original message in case of parse problems
      target => "parsed"
      tag_on_failure => ["_jsonparsefailure"]
    }
  }
}

if "_jsonparsefailure" in [tags] {
  mutate { add_field => { "parse_error" => "%{message}" } }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "microservices-%{+YYYY.MM.dd}"
    # If you want to set a document_type for older ES versions:
    # document_type => "%{[@metadata][type]}"
    retry_on_conflict => 3
  }

  # Useful during local development to see what Logstash receives
  stdout {
    codec => rubydebug
  }
}
